// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#ifndef PROTOBUF_core_2eproto__INCLUDED
#define PROTOBUF_core_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "core-x86.pb.h"
#include "core-arm.pb.h"
#include "core-aarch64.pb.h"
#include "core-ppc64.pb.h"
#include "rlimit.pb.h"
#include "timer.pb.h"
#include "creds.pb.h"
#include "siginfo.pb.h"
#include "opts.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_core_2eproto();
void protobuf_AssignDesc_core_2eproto();
void protobuf_ShutdownFile_core_2eproto();

class task_core_entry;
class task_kobj_ids_entry;
class thread_sas_entry;
class thread_core_entry;
class task_rlimits_entry;
class core_entry;

enum core_entry_march {
  core_entry_march_UNKNOWN = 0,
  core_entry_march_X86_64 = 1,
  core_entry_march_ARM = 2,
  core_entry_march_AARCH64 = 3,
  core_entry_march_PPC64 = 4
};
bool core_entry_march_IsValid(int value);
const core_entry_march core_entry_march_march_MIN = core_entry_march_UNKNOWN;
const core_entry_march core_entry_march_march_MAX = core_entry_march_PPC64;
const int core_entry_march_march_ARRAYSIZE = core_entry_march_march_MAX + 1;

const ::google::protobuf::EnumDescriptor* core_entry_march_descriptor();
inline const ::std::string& core_entry_march_Name(core_entry_march value) {
  return ::google::protobuf::internal::NameOfEnum(
    core_entry_march_descriptor(), value);
}
inline bool core_entry_march_Parse(
    const ::std::string& name, core_entry_march* value) {
  return ::google::protobuf::internal::ParseNamedEnum<core_entry_march>(
    core_entry_march_descriptor(), name, value);
}
enum seccomp_mode {
  disabled = 0,
  strict = 1,
  filter = 2
};
bool seccomp_mode_IsValid(int value);
const seccomp_mode seccomp_mode_MIN = disabled;
const seccomp_mode seccomp_mode_MAX = filter;
const int seccomp_mode_ARRAYSIZE = seccomp_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* seccomp_mode_descriptor();
inline const ::std::string& seccomp_mode_Name(seccomp_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    seccomp_mode_descriptor(), value);
}
inline bool seccomp_mode_Parse(
    const ::std::string& name, seccomp_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<seccomp_mode>(
    seccomp_mode_descriptor(), name, value);
}
// ===================================================================

class task_core_entry : public ::google::protobuf::Message {
 public:
  task_core_entry();
  virtual ~task_core_entry();

  task_core_entry(const task_core_entry& from);

  inline task_core_entry& operator=(const task_core_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_core_entry& default_instance();

  void Swap(task_core_entry* other);

  // implements Message ----------------------------------------------

  task_core_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_core_entry& from);
  void MergeFrom(const task_core_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_state = 1;
  inline bool has_task_state() const;
  inline void clear_task_state();
  static const int kTaskStateFieldNumber = 1;
  inline ::google::protobuf::uint32 task_state() const;
  inline void set_task_state(::google::protobuf::uint32 value);

  // required uint32 exit_code = 2;
  inline bool has_exit_code() const;
  inline void clear_exit_code();
  static const int kExitCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 exit_code() const;
  inline void set_exit_code(::google::protobuf::uint32 value);

  // required uint32 personality = 3;
  inline bool has_personality() const;
  inline void clear_personality();
  static const int kPersonalityFieldNumber = 3;
  inline ::google::protobuf::uint32 personality() const;
  inline void set_personality(::google::protobuf::uint32 value);

  // required uint32 flags = 4;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 4;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // required uint64 blk_sigset = 5;
  inline bool has_blk_sigset() const;
  inline void clear_blk_sigset();
  static const int kBlkSigsetFieldNumber = 5;
  inline ::google::protobuf::uint64 blk_sigset() const;
  inline void set_blk_sigset(::google::protobuf::uint64 value);

  // required string comm = 6;
  inline bool has_comm() const;
  inline void clear_comm();
  static const int kCommFieldNumber = 6;
  inline const ::std::string& comm() const;
  inline void set_comm(const ::std::string& value);
  inline void set_comm(const char* value);
  inline void set_comm(const char* value, size_t size);
  inline ::std::string* mutable_comm();
  inline ::std::string* release_comm();
  inline void set_allocated_comm(::std::string* comm);

  // optional .task_timers_entry timers = 7;
  inline bool has_timers() const;
  inline void clear_timers();
  static const int kTimersFieldNumber = 7;
  inline const ::task_timers_entry& timers() const;
  inline ::task_timers_entry* mutable_timers();
  inline ::task_timers_entry* release_timers();
  inline void set_allocated_timers(::task_timers_entry* timers);

  // optional .task_rlimits_entry rlimits = 8;
  inline bool has_rlimits() const;
  inline void clear_rlimits();
  static const int kRlimitsFieldNumber = 8;
  inline const ::task_rlimits_entry& rlimits() const;
  inline ::task_rlimits_entry* mutable_rlimits();
  inline ::task_rlimits_entry* release_rlimits();
  inline void set_allocated_rlimits(::task_rlimits_entry* rlimits);

  // optional uint32 cg_set = 9;
  inline bool has_cg_set() const;
  inline void clear_cg_set();
  static const int kCgSetFieldNumber = 9;
  inline ::google::protobuf::uint32 cg_set() const;
  inline void set_cg_set(::google::protobuf::uint32 value);

  // optional .signal_queue_entry signals_s = 10;
  inline bool has_signals_s() const;
  inline void clear_signals_s();
  static const int kSignalsSFieldNumber = 10;
  inline const ::signal_queue_entry& signals_s() const;
  inline ::signal_queue_entry* mutable_signals_s();
  inline ::signal_queue_entry* release_signals_s();
  inline void set_allocated_signals_s(::signal_queue_entry* signals_s);

  // optional .seccomp_mode seccomp_mode = 11;
  inline bool has_seccomp_mode() const;
  inline void clear_seccomp_mode();
  static const int kSeccompModeFieldNumber = 11;
  inline ::seccomp_mode seccomp_mode() const;
  inline void set_seccomp_mode(::seccomp_mode value);

  // optional uint32 seccomp_filter = 12;
  inline bool has_seccomp_filter() const;
  inline void clear_seccomp_filter();
  static const int kSeccompFilterFieldNumber = 12;
  inline ::google::protobuf::uint32 seccomp_filter() const;
  inline void set_seccomp_filter(::google::protobuf::uint32 value);

  // optional uint32 loginuid = 13;
  inline bool has_loginuid() const;
  inline void clear_loginuid();
  static const int kLoginuidFieldNumber = 13;
  inline ::google::protobuf::uint32 loginuid() const;
  inline void set_loginuid(::google::protobuf::uint32 value);

  // optional int32 oom_score_adj = 14;
  inline bool has_oom_score_adj() const;
  inline void clear_oom_score_adj();
  static const int kOomScoreAdjFieldNumber = 14;
  inline ::google::protobuf::int32 oom_score_adj() const;
  inline void set_oom_score_adj(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:task_core_entry)
 private:
  inline void set_has_task_state();
  inline void clear_has_task_state();
  inline void set_has_exit_code();
  inline void clear_has_exit_code();
  inline void set_has_personality();
  inline void clear_has_personality();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_blk_sigset();
  inline void clear_has_blk_sigset();
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_timers();
  inline void clear_has_timers();
  inline void set_has_rlimits();
  inline void clear_has_rlimits();
  inline void set_has_cg_set();
  inline void clear_has_cg_set();
  inline void set_has_signals_s();
  inline void clear_has_signals_s();
  inline void set_has_seccomp_mode();
  inline void clear_has_seccomp_mode();
  inline void set_has_seccomp_filter();
  inline void clear_has_seccomp_filter();
  inline void set_has_loginuid();
  inline void clear_has_loginuid();
  inline void set_has_oom_score_adj();
  inline void clear_has_oom_score_adj();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 task_state_;
  ::google::protobuf::uint32 exit_code_;
  ::google::protobuf::uint32 personality_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint64 blk_sigset_;
  ::std::string* comm_;
  ::task_timers_entry* timers_;
  ::task_rlimits_entry* rlimits_;
  ::signal_queue_entry* signals_s_;
  ::google::protobuf::uint32 cg_set_;
  int seccomp_mode_;
  ::google::protobuf::uint32 seccomp_filter_;
  ::google::protobuf::uint32 loginuid_;
  ::google::protobuf::int32 oom_score_adj_;
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static task_core_entry* default_instance_;
};
// -------------------------------------------------------------------

class task_kobj_ids_entry : public ::google::protobuf::Message {
 public:
  task_kobj_ids_entry();
  virtual ~task_kobj_ids_entry();

  task_kobj_ids_entry(const task_kobj_ids_entry& from);

  inline task_kobj_ids_entry& operator=(const task_kobj_ids_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_kobj_ids_entry& default_instance();

  void Swap(task_kobj_ids_entry* other);

  // implements Message ----------------------------------------------

  task_kobj_ids_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_kobj_ids_entry& from);
  void MergeFrom(const task_kobj_ids_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 vm_id = 1;
  inline bool has_vm_id() const;
  inline void clear_vm_id();
  static const int kVmIdFieldNumber = 1;
  inline ::google::protobuf::uint32 vm_id() const;
  inline void set_vm_id(::google::protobuf::uint32 value);

  // required uint32 files_id = 2;
  inline bool has_files_id() const;
  inline void clear_files_id();
  static const int kFilesIdFieldNumber = 2;
  inline ::google::protobuf::uint32 files_id() const;
  inline void set_files_id(::google::protobuf::uint32 value);

  // required uint32 fs_id = 3;
  inline bool has_fs_id() const;
  inline void clear_fs_id();
  static const int kFsIdFieldNumber = 3;
  inline ::google::protobuf::uint32 fs_id() const;
  inline void set_fs_id(::google::protobuf::uint32 value);

  // required uint32 sighand_id = 4;
  inline bool has_sighand_id() const;
  inline void clear_sighand_id();
  static const int kSighandIdFieldNumber = 4;
  inline ::google::protobuf::uint32 sighand_id() const;
  inline void set_sighand_id(::google::protobuf::uint32 value);

  // optional uint32 pid_ns_id = 5;
  inline bool has_pid_ns_id() const;
  inline void clear_pid_ns_id();
  static const int kPidNsIdFieldNumber = 5;
  inline ::google::protobuf::uint32 pid_ns_id() const;
  inline void set_pid_ns_id(::google::protobuf::uint32 value);

  // optional uint32 net_ns_id = 6;
  inline bool has_net_ns_id() const;
  inline void clear_net_ns_id();
  static const int kNetNsIdFieldNumber = 6;
  inline ::google::protobuf::uint32 net_ns_id() const;
  inline void set_net_ns_id(::google::protobuf::uint32 value);

  // optional uint32 ipc_ns_id = 7;
  inline bool has_ipc_ns_id() const;
  inline void clear_ipc_ns_id();
  static const int kIpcNsIdFieldNumber = 7;
  inline ::google::protobuf::uint32 ipc_ns_id() const;
  inline void set_ipc_ns_id(::google::protobuf::uint32 value);

  // optional uint32 uts_ns_id = 8;
  inline bool has_uts_ns_id() const;
  inline void clear_uts_ns_id();
  static const int kUtsNsIdFieldNumber = 8;
  inline ::google::protobuf::uint32 uts_ns_id() const;
  inline void set_uts_ns_id(::google::protobuf::uint32 value);

  // optional uint32 mnt_ns_id = 9;
  inline bool has_mnt_ns_id() const;
  inline void clear_mnt_ns_id();
  static const int kMntNsIdFieldNumber = 9;
  inline ::google::protobuf::uint32 mnt_ns_id() const;
  inline void set_mnt_ns_id(::google::protobuf::uint32 value);

  // optional uint32 user_ns_id = 10;
  inline bool has_user_ns_id() const;
  inline void clear_user_ns_id();
  static const int kUserNsIdFieldNumber = 10;
  inline ::google::protobuf::uint32 user_ns_id() const;
  inline void set_user_ns_id(::google::protobuf::uint32 value);

  // optional uint32 cgroup_ns_id = 11;
  inline bool has_cgroup_ns_id() const;
  inline void clear_cgroup_ns_id();
  static const int kCgroupNsIdFieldNumber = 11;
  inline ::google::protobuf::uint32 cgroup_ns_id() const;
  inline void set_cgroup_ns_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:task_kobj_ids_entry)
 private:
  inline void set_has_vm_id();
  inline void clear_has_vm_id();
  inline void set_has_files_id();
  inline void clear_has_files_id();
  inline void set_has_fs_id();
  inline void clear_has_fs_id();
  inline void set_has_sighand_id();
  inline void clear_has_sighand_id();
  inline void set_has_pid_ns_id();
  inline void clear_has_pid_ns_id();
  inline void set_has_net_ns_id();
  inline void clear_has_net_ns_id();
  inline void set_has_ipc_ns_id();
  inline void clear_has_ipc_ns_id();
  inline void set_has_uts_ns_id();
  inline void clear_has_uts_ns_id();
  inline void set_has_mnt_ns_id();
  inline void clear_has_mnt_ns_id();
  inline void set_has_user_ns_id();
  inline void clear_has_user_ns_id();
  inline void set_has_cgroup_ns_id();
  inline void clear_has_cgroup_ns_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 vm_id_;
  ::google::protobuf::uint32 files_id_;
  ::google::protobuf::uint32 fs_id_;
  ::google::protobuf::uint32 sighand_id_;
  ::google::protobuf::uint32 pid_ns_id_;
  ::google::protobuf::uint32 net_ns_id_;
  ::google::protobuf::uint32 ipc_ns_id_;
  ::google::protobuf::uint32 uts_ns_id_;
  ::google::protobuf::uint32 mnt_ns_id_;
  ::google::protobuf::uint32 user_ns_id_;
  ::google::protobuf::uint32 cgroup_ns_id_;
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static task_kobj_ids_entry* default_instance_;
};
// -------------------------------------------------------------------

class thread_sas_entry : public ::google::protobuf::Message {
 public:
  thread_sas_entry();
  virtual ~thread_sas_entry();

  thread_sas_entry(const thread_sas_entry& from);

  inline thread_sas_entry& operator=(const thread_sas_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const thread_sas_entry& default_instance();

  void Swap(thread_sas_entry* other);

  // implements Message ----------------------------------------------

  thread_sas_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const thread_sas_entry& from);
  void MergeFrom(const thread_sas_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ss_sp = 1;
  inline bool has_ss_sp() const;
  inline void clear_ss_sp();
  static const int kSsSpFieldNumber = 1;
  inline ::google::protobuf::uint64 ss_sp() const;
  inline void set_ss_sp(::google::protobuf::uint64 value);

  // required uint64 ss_size = 2;
  inline bool has_ss_size() const;
  inline void clear_ss_size();
  static const int kSsSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 ss_size() const;
  inline void set_ss_size(::google::protobuf::uint64 value);

  // required uint32 ss_flags = 3;
  inline bool has_ss_flags() const;
  inline void clear_ss_flags();
  static const int kSsFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 ss_flags() const;
  inline void set_ss_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:thread_sas_entry)
 private:
  inline void set_has_ss_sp();
  inline void clear_has_ss_sp();
  inline void set_has_ss_size();
  inline void clear_has_ss_size();
  inline void set_has_ss_flags();
  inline void clear_has_ss_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 ss_sp_;
  ::google::protobuf::uint64 ss_size_;
  ::google::protobuf::uint32 ss_flags_;
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static thread_sas_entry* default_instance_;
};
// -------------------------------------------------------------------

class thread_core_entry : public ::google::protobuf::Message {
 public:
  thread_core_entry();
  virtual ~thread_core_entry();

  thread_core_entry(const thread_core_entry& from);

  inline thread_core_entry& operator=(const thread_core_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const thread_core_entry& default_instance();

  void Swap(thread_core_entry* other);

  // implements Message ----------------------------------------------

  thread_core_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const thread_core_entry& from);
  void MergeFrom(const thread_core_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 futex_rla = 1;
  inline bool has_futex_rla() const;
  inline void clear_futex_rla();
  static const int kFutexRlaFieldNumber = 1;
  inline ::google::protobuf::uint64 futex_rla() const;
  inline void set_futex_rla(::google::protobuf::uint64 value);

  // required uint32 futex_rla_len = 2;
  inline bool has_futex_rla_len() const;
  inline void clear_futex_rla_len();
  static const int kFutexRlaLenFieldNumber = 2;
  inline ::google::protobuf::uint32 futex_rla_len() const;
  inline void set_futex_rla_len(::google::protobuf::uint32 value);

  // optional sint32 sched_nice = 3;
  inline bool has_sched_nice() const;
  inline void clear_sched_nice();
  static const int kSchedNiceFieldNumber = 3;
  inline ::google::protobuf::int32 sched_nice() const;
  inline void set_sched_nice(::google::protobuf::int32 value);

  // optional uint32 sched_policy = 4;
  inline bool has_sched_policy() const;
  inline void clear_sched_policy();
  static const int kSchedPolicyFieldNumber = 4;
  inline ::google::protobuf::uint32 sched_policy() const;
  inline void set_sched_policy(::google::protobuf::uint32 value);

  // optional uint32 sched_prio = 5;
  inline bool has_sched_prio() const;
  inline void clear_sched_prio();
  static const int kSchedPrioFieldNumber = 5;
  inline ::google::protobuf::uint32 sched_prio() const;
  inline void set_sched_prio(::google::protobuf::uint32 value);

  // optional uint64 blk_sigset = 6;
  inline bool has_blk_sigset() const;
  inline void clear_blk_sigset();
  static const int kBlkSigsetFieldNumber = 6;
  inline ::google::protobuf::uint64 blk_sigset() const;
  inline void set_blk_sigset(::google::protobuf::uint64 value);

  // optional .thread_sas_entry sas = 7;
  inline bool has_sas() const;
  inline void clear_sas();
  static const int kSasFieldNumber = 7;
  inline const ::thread_sas_entry& sas() const;
  inline ::thread_sas_entry* mutable_sas();
  inline ::thread_sas_entry* release_sas();
  inline void set_allocated_sas(::thread_sas_entry* sas);

  // optional uint32 pdeath_sig = 8;
  inline bool has_pdeath_sig() const;
  inline void clear_pdeath_sig();
  static const int kPdeathSigFieldNumber = 8;
  inline ::google::protobuf::uint32 pdeath_sig() const;
  inline void set_pdeath_sig(::google::protobuf::uint32 value);

  // optional .signal_queue_entry signals_p = 9;
  inline bool has_signals_p() const;
  inline void clear_signals_p();
  static const int kSignalsPFieldNumber = 9;
  inline const ::signal_queue_entry& signals_p() const;
  inline ::signal_queue_entry* mutable_signals_p();
  inline ::signal_queue_entry* release_signals_p();
  inline void set_allocated_signals_p(::signal_queue_entry* signals_p);

  // optional .creds_entry creds = 10;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 10;
  inline const ::creds_entry& creds() const;
  inline ::creds_entry* mutable_creds();
  inline ::creds_entry* release_creds();
  inline void set_allocated_creds(::creds_entry* creds);

  // @@protoc_insertion_point(class_scope:thread_core_entry)
 private:
  inline void set_has_futex_rla();
  inline void clear_has_futex_rla();
  inline void set_has_futex_rla_len();
  inline void clear_has_futex_rla_len();
  inline void set_has_sched_nice();
  inline void clear_has_sched_nice();
  inline void set_has_sched_policy();
  inline void clear_has_sched_policy();
  inline void set_has_sched_prio();
  inline void clear_has_sched_prio();
  inline void set_has_blk_sigset();
  inline void clear_has_blk_sigset();
  inline void set_has_sas();
  inline void clear_has_sas();
  inline void set_has_pdeath_sig();
  inline void clear_has_pdeath_sig();
  inline void set_has_signals_p();
  inline void clear_has_signals_p();
  inline void set_has_creds();
  inline void clear_has_creds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 futex_rla_;
  ::google::protobuf::uint32 futex_rla_len_;
  ::google::protobuf::int32 sched_nice_;
  ::google::protobuf::uint32 sched_policy_;
  ::google::protobuf::uint32 sched_prio_;
  ::google::protobuf::uint64 blk_sigset_;
  ::thread_sas_entry* sas_;
  ::signal_queue_entry* signals_p_;
  ::creds_entry* creds_;
  ::google::protobuf::uint32 pdeath_sig_;
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static thread_core_entry* default_instance_;
};
// -------------------------------------------------------------------

class task_rlimits_entry : public ::google::protobuf::Message {
 public:
  task_rlimits_entry();
  virtual ~task_rlimits_entry();

  task_rlimits_entry(const task_rlimits_entry& from);

  inline task_rlimits_entry& operator=(const task_rlimits_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_rlimits_entry& default_instance();

  void Swap(task_rlimits_entry* other);

  // implements Message ----------------------------------------------

  task_rlimits_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_rlimits_entry& from);
  void MergeFrom(const task_rlimits_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rlimit_entry rlimits = 1;
  inline int rlimits_size() const;
  inline void clear_rlimits();
  static const int kRlimitsFieldNumber = 1;
  inline const ::rlimit_entry& rlimits(int index) const;
  inline ::rlimit_entry* mutable_rlimits(int index);
  inline ::rlimit_entry* add_rlimits();
  inline const ::google::protobuf::RepeatedPtrField< ::rlimit_entry >&
      rlimits() const;
  inline ::google::protobuf::RepeatedPtrField< ::rlimit_entry >*
      mutable_rlimits();

  // @@protoc_insertion_point(class_scope:task_rlimits_entry)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::rlimit_entry > rlimits_;
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static task_rlimits_entry* default_instance_;
};
// -------------------------------------------------------------------

class core_entry : public ::google::protobuf::Message {
 public:
  core_entry();
  virtual ~core_entry();

  core_entry(const core_entry& from);

  inline core_entry& operator=(const core_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const core_entry& default_instance();

  void Swap(core_entry* other);

  // implements Message ----------------------------------------------

  core_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const core_entry& from);
  void MergeFrom(const core_entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef core_entry_march march;
  static const march UNKNOWN = core_entry_march_UNKNOWN;
  static const march X86_64 = core_entry_march_X86_64;
  static const march ARM = core_entry_march_ARM;
  static const march AARCH64 = core_entry_march_AARCH64;
  static const march PPC64 = core_entry_march_PPC64;
  static inline bool march_IsValid(int value) {
    return core_entry_march_IsValid(value);
  }
  static const march march_MIN =
    core_entry_march_march_MIN;
  static const march march_MAX =
    core_entry_march_march_MAX;
  static const int march_ARRAYSIZE =
    core_entry_march_march_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  march_descriptor() {
    return core_entry_march_descriptor();
  }
  static inline const ::std::string& march_Name(march value) {
    return core_entry_march_Name(value);
  }
  static inline bool march_Parse(const ::std::string& name,
      march* value) {
    return core_entry_march_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .core_entry.march mtype = 1;
  inline bool has_mtype() const;
  inline void clear_mtype();
  static const int kMtypeFieldNumber = 1;
  inline ::core_entry_march mtype() const;
  inline void set_mtype(::core_entry_march value);

  // optional .thread_info_x86 thread_info = 2;
  inline bool has_thread_info() const;
  inline void clear_thread_info();
  static const int kThreadInfoFieldNumber = 2;
  inline const ::thread_info_x86& thread_info() const;
  inline ::thread_info_x86* mutable_thread_info();
  inline ::thread_info_x86* release_thread_info();
  inline void set_allocated_thread_info(::thread_info_x86* thread_info);

  // optional .thread_info_arm ti_arm = 6;
  inline bool has_ti_arm() const;
  inline void clear_ti_arm();
  static const int kTiArmFieldNumber = 6;
  inline const ::thread_info_arm& ti_arm() const;
  inline ::thread_info_arm* mutable_ti_arm();
  inline ::thread_info_arm* release_ti_arm();
  inline void set_allocated_ti_arm(::thread_info_arm* ti_arm);

  // optional .thread_info_aarch64 ti_aarch64 = 8;
  inline bool has_ti_aarch64() const;
  inline void clear_ti_aarch64();
  static const int kTiAarch64FieldNumber = 8;
  inline const ::thread_info_aarch64& ti_aarch64() const;
  inline ::thread_info_aarch64* mutable_ti_aarch64();
  inline ::thread_info_aarch64* release_ti_aarch64();
  inline void set_allocated_ti_aarch64(::thread_info_aarch64* ti_aarch64);

  // optional .thread_info_ppc64 ti_ppc64 = 9;
  inline bool has_ti_ppc64() const;
  inline void clear_ti_ppc64();
  static const int kTiPpc64FieldNumber = 9;
  inline const ::thread_info_ppc64& ti_ppc64() const;
  inline ::thread_info_ppc64* mutable_ti_ppc64();
  inline ::thread_info_ppc64* release_ti_ppc64();
  inline void set_allocated_ti_ppc64(::thread_info_ppc64* ti_ppc64);

  // optional .task_core_entry tc = 3;
  inline bool has_tc() const;
  inline void clear_tc();
  static const int kTcFieldNumber = 3;
  inline const ::task_core_entry& tc() const;
  inline ::task_core_entry* mutable_tc();
  inline ::task_core_entry* release_tc();
  inline void set_allocated_tc(::task_core_entry* tc);

  // optional .task_kobj_ids_entry ids = 4;
  inline bool has_ids() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 4;
  inline const ::task_kobj_ids_entry& ids() const;
  inline ::task_kobj_ids_entry* mutable_ids();
  inline ::task_kobj_ids_entry* release_ids();
  inline void set_allocated_ids(::task_kobj_ids_entry* ids);

  // optional .thread_core_entry thread_core = 5;
  inline bool has_thread_core() const;
  inline void clear_thread_core();
  static const int kThreadCoreFieldNumber = 5;
  inline const ::thread_core_entry& thread_core() const;
  inline ::thread_core_entry* mutable_thread_core();
  inline ::thread_core_entry* release_thread_core();
  inline void set_allocated_thread_core(::thread_core_entry* thread_core);

  // @@protoc_insertion_point(class_scope:core_entry)
 private:
  inline void set_has_mtype();
  inline void clear_has_mtype();
  inline void set_has_thread_info();
  inline void clear_has_thread_info();
  inline void set_has_ti_arm();
  inline void clear_has_ti_arm();
  inline void set_has_ti_aarch64();
  inline void clear_has_ti_aarch64();
  inline void set_has_ti_ppc64();
  inline void clear_has_ti_ppc64();
  inline void set_has_tc();
  inline void clear_has_tc();
  inline void set_has_ids();
  inline void clear_has_ids();
  inline void set_has_thread_core();
  inline void clear_has_thread_core();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::thread_info_x86* thread_info_;
  ::thread_info_arm* ti_arm_;
  ::thread_info_aarch64* ti_aarch64_;
  ::thread_info_ppc64* ti_ppc64_;
  ::task_core_entry* tc_;
  ::task_kobj_ids_entry* ids_;
  ::thread_core_entry* thread_core_;
  int mtype_;
  friend void  protobuf_AddDesc_core_2eproto();
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static core_entry* default_instance_;
};
// ===================================================================


// ===================================================================

// task_core_entry

// required uint32 task_state = 1;
inline bool task_core_entry::has_task_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_core_entry::set_has_task_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_core_entry::clear_has_task_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_core_entry::clear_task_state() {
  task_state_ = 0u;
  clear_has_task_state();
}
inline ::google::protobuf::uint32 task_core_entry::task_state() const {
  // @@protoc_insertion_point(field_get:task_core_entry.task_state)
  return task_state_;
}
inline void task_core_entry::set_task_state(::google::protobuf::uint32 value) {
  set_has_task_state();
  task_state_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.task_state)
}

// required uint32 exit_code = 2;
inline bool task_core_entry::has_exit_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_core_entry::set_has_exit_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_core_entry::clear_has_exit_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_core_entry::clear_exit_code() {
  exit_code_ = 0u;
  clear_has_exit_code();
}
inline ::google::protobuf::uint32 task_core_entry::exit_code() const {
  // @@protoc_insertion_point(field_get:task_core_entry.exit_code)
  return exit_code_;
}
inline void task_core_entry::set_exit_code(::google::protobuf::uint32 value) {
  set_has_exit_code();
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.exit_code)
}

// required uint32 personality = 3;
inline bool task_core_entry::has_personality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void task_core_entry::set_has_personality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void task_core_entry::clear_has_personality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void task_core_entry::clear_personality() {
  personality_ = 0u;
  clear_has_personality();
}
inline ::google::protobuf::uint32 task_core_entry::personality() const {
  // @@protoc_insertion_point(field_get:task_core_entry.personality)
  return personality_;
}
inline void task_core_entry::set_personality(::google::protobuf::uint32 value) {
  set_has_personality();
  personality_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.personality)
}

// required uint32 flags = 4;
inline bool task_core_entry::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void task_core_entry::set_has_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void task_core_entry::clear_has_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void task_core_entry::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 task_core_entry::flags() const {
  // @@protoc_insertion_point(field_get:task_core_entry.flags)
  return flags_;
}
inline void task_core_entry::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.flags)
}

// required uint64 blk_sigset = 5;
inline bool task_core_entry::has_blk_sigset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void task_core_entry::set_has_blk_sigset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void task_core_entry::clear_has_blk_sigset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void task_core_entry::clear_blk_sigset() {
  blk_sigset_ = GOOGLE_ULONGLONG(0);
  clear_has_blk_sigset();
}
inline ::google::protobuf::uint64 task_core_entry::blk_sigset() const {
  // @@protoc_insertion_point(field_get:task_core_entry.blk_sigset)
  return blk_sigset_;
}
inline void task_core_entry::set_blk_sigset(::google::protobuf::uint64 value) {
  set_has_blk_sigset();
  blk_sigset_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.blk_sigset)
}

// required string comm = 6;
inline bool task_core_entry::has_comm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void task_core_entry::set_has_comm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void task_core_entry::clear_has_comm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void task_core_entry::clear_comm() {
  if (comm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comm_->clear();
  }
  clear_has_comm();
}
inline const ::std::string& task_core_entry::comm() const {
  // @@protoc_insertion_point(field_get:task_core_entry.comm)
  return *comm_;
}
inline void task_core_entry::set_comm(const ::std::string& value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
  // @@protoc_insertion_point(field_set:task_core_entry.comm)
}
inline void task_core_entry::set_comm(const char* value) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comm_ = new ::std::string;
  }
  comm_->assign(value);
  // @@protoc_insertion_point(field_set_char:task_core_entry.comm)
}
inline void task_core_entry::set_comm(const char* value, size_t size) {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comm_ = new ::std::string;
  }
  comm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:task_core_entry.comm)
}
inline ::std::string* task_core_entry::mutable_comm() {
  set_has_comm();
  if (comm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:task_core_entry.comm)
  return comm_;
}
inline ::std::string* task_core_entry::release_comm() {
  clear_has_comm();
  if (comm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comm_;
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void task_core_entry::set_allocated_comm(::std::string* comm) {
  if (comm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comm_;
  }
  if (comm) {
    set_has_comm();
    comm_ = comm;
  } else {
    clear_has_comm();
    comm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:task_core_entry.comm)
}

// optional .task_timers_entry timers = 7;
inline bool task_core_entry::has_timers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void task_core_entry::set_has_timers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void task_core_entry::clear_has_timers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void task_core_entry::clear_timers() {
  if (timers_ != NULL) timers_->::task_timers_entry::Clear();
  clear_has_timers();
}
inline const ::task_timers_entry& task_core_entry::timers() const {
  // @@protoc_insertion_point(field_get:task_core_entry.timers)
  return timers_ != NULL ? *timers_ : *default_instance_->timers_;
}
inline ::task_timers_entry* task_core_entry::mutable_timers() {
  set_has_timers();
  if (timers_ == NULL) timers_ = new ::task_timers_entry;
  // @@protoc_insertion_point(field_mutable:task_core_entry.timers)
  return timers_;
}
inline ::task_timers_entry* task_core_entry::release_timers() {
  clear_has_timers();
  ::task_timers_entry* temp = timers_;
  timers_ = NULL;
  return temp;
}
inline void task_core_entry::set_allocated_timers(::task_timers_entry* timers) {
  delete timers_;
  timers_ = timers;
  if (timers) {
    set_has_timers();
  } else {
    clear_has_timers();
  }
  // @@protoc_insertion_point(field_set_allocated:task_core_entry.timers)
}

// optional .task_rlimits_entry rlimits = 8;
inline bool task_core_entry::has_rlimits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void task_core_entry::set_has_rlimits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void task_core_entry::clear_has_rlimits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void task_core_entry::clear_rlimits() {
  if (rlimits_ != NULL) rlimits_->::task_rlimits_entry::Clear();
  clear_has_rlimits();
}
inline const ::task_rlimits_entry& task_core_entry::rlimits() const {
  // @@protoc_insertion_point(field_get:task_core_entry.rlimits)
  return rlimits_ != NULL ? *rlimits_ : *default_instance_->rlimits_;
}
inline ::task_rlimits_entry* task_core_entry::mutable_rlimits() {
  set_has_rlimits();
  if (rlimits_ == NULL) rlimits_ = new ::task_rlimits_entry;
  // @@protoc_insertion_point(field_mutable:task_core_entry.rlimits)
  return rlimits_;
}
inline ::task_rlimits_entry* task_core_entry::release_rlimits() {
  clear_has_rlimits();
  ::task_rlimits_entry* temp = rlimits_;
  rlimits_ = NULL;
  return temp;
}
inline void task_core_entry::set_allocated_rlimits(::task_rlimits_entry* rlimits) {
  delete rlimits_;
  rlimits_ = rlimits;
  if (rlimits) {
    set_has_rlimits();
  } else {
    clear_has_rlimits();
  }
  // @@protoc_insertion_point(field_set_allocated:task_core_entry.rlimits)
}

// optional uint32 cg_set = 9;
inline bool task_core_entry::has_cg_set() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void task_core_entry::set_has_cg_set() {
  _has_bits_[0] |= 0x00000100u;
}
inline void task_core_entry::clear_has_cg_set() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void task_core_entry::clear_cg_set() {
  cg_set_ = 0u;
  clear_has_cg_set();
}
inline ::google::protobuf::uint32 task_core_entry::cg_set() const {
  // @@protoc_insertion_point(field_get:task_core_entry.cg_set)
  return cg_set_;
}
inline void task_core_entry::set_cg_set(::google::protobuf::uint32 value) {
  set_has_cg_set();
  cg_set_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.cg_set)
}

// optional .signal_queue_entry signals_s = 10;
inline bool task_core_entry::has_signals_s() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void task_core_entry::set_has_signals_s() {
  _has_bits_[0] |= 0x00000200u;
}
inline void task_core_entry::clear_has_signals_s() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void task_core_entry::clear_signals_s() {
  if (signals_s_ != NULL) signals_s_->::signal_queue_entry::Clear();
  clear_has_signals_s();
}
inline const ::signal_queue_entry& task_core_entry::signals_s() const {
  // @@protoc_insertion_point(field_get:task_core_entry.signals_s)
  return signals_s_ != NULL ? *signals_s_ : *default_instance_->signals_s_;
}
inline ::signal_queue_entry* task_core_entry::mutable_signals_s() {
  set_has_signals_s();
  if (signals_s_ == NULL) signals_s_ = new ::signal_queue_entry;
  // @@protoc_insertion_point(field_mutable:task_core_entry.signals_s)
  return signals_s_;
}
inline ::signal_queue_entry* task_core_entry::release_signals_s() {
  clear_has_signals_s();
  ::signal_queue_entry* temp = signals_s_;
  signals_s_ = NULL;
  return temp;
}
inline void task_core_entry::set_allocated_signals_s(::signal_queue_entry* signals_s) {
  delete signals_s_;
  signals_s_ = signals_s;
  if (signals_s) {
    set_has_signals_s();
  } else {
    clear_has_signals_s();
  }
  // @@protoc_insertion_point(field_set_allocated:task_core_entry.signals_s)
}

// optional .seccomp_mode seccomp_mode = 11;
inline bool task_core_entry::has_seccomp_mode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void task_core_entry::set_has_seccomp_mode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void task_core_entry::clear_has_seccomp_mode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void task_core_entry::clear_seccomp_mode() {
  seccomp_mode_ = 0;
  clear_has_seccomp_mode();
}
inline ::seccomp_mode task_core_entry::seccomp_mode() const {
  // @@protoc_insertion_point(field_get:task_core_entry.seccomp_mode)
  return static_cast< ::seccomp_mode >(seccomp_mode_);
}
inline void task_core_entry::set_seccomp_mode(::seccomp_mode value) {
  assert(::seccomp_mode_IsValid(value));
  set_has_seccomp_mode();
  seccomp_mode_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.seccomp_mode)
}

// optional uint32 seccomp_filter = 12;
inline bool task_core_entry::has_seccomp_filter() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void task_core_entry::set_has_seccomp_filter() {
  _has_bits_[0] |= 0x00000800u;
}
inline void task_core_entry::clear_has_seccomp_filter() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void task_core_entry::clear_seccomp_filter() {
  seccomp_filter_ = 0u;
  clear_has_seccomp_filter();
}
inline ::google::protobuf::uint32 task_core_entry::seccomp_filter() const {
  // @@protoc_insertion_point(field_get:task_core_entry.seccomp_filter)
  return seccomp_filter_;
}
inline void task_core_entry::set_seccomp_filter(::google::protobuf::uint32 value) {
  set_has_seccomp_filter();
  seccomp_filter_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.seccomp_filter)
}

// optional uint32 loginuid = 13;
inline bool task_core_entry::has_loginuid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void task_core_entry::set_has_loginuid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void task_core_entry::clear_has_loginuid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void task_core_entry::clear_loginuid() {
  loginuid_ = 0u;
  clear_has_loginuid();
}
inline ::google::protobuf::uint32 task_core_entry::loginuid() const {
  // @@protoc_insertion_point(field_get:task_core_entry.loginuid)
  return loginuid_;
}
inline void task_core_entry::set_loginuid(::google::protobuf::uint32 value) {
  set_has_loginuid();
  loginuid_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.loginuid)
}

// optional int32 oom_score_adj = 14;
inline bool task_core_entry::has_oom_score_adj() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void task_core_entry::set_has_oom_score_adj() {
  _has_bits_[0] |= 0x00002000u;
}
inline void task_core_entry::clear_has_oom_score_adj() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void task_core_entry::clear_oom_score_adj() {
  oom_score_adj_ = 0;
  clear_has_oom_score_adj();
}
inline ::google::protobuf::int32 task_core_entry::oom_score_adj() const {
  // @@protoc_insertion_point(field_get:task_core_entry.oom_score_adj)
  return oom_score_adj_;
}
inline void task_core_entry::set_oom_score_adj(::google::protobuf::int32 value) {
  set_has_oom_score_adj();
  oom_score_adj_ = value;
  // @@protoc_insertion_point(field_set:task_core_entry.oom_score_adj)
}

// -------------------------------------------------------------------

// task_kobj_ids_entry

// required uint32 vm_id = 1;
inline bool task_kobj_ids_entry::has_vm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_kobj_ids_entry::set_has_vm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_kobj_ids_entry::clear_has_vm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_kobj_ids_entry::clear_vm_id() {
  vm_id_ = 0u;
  clear_has_vm_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::vm_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.vm_id)
  return vm_id_;
}
inline void task_kobj_ids_entry::set_vm_id(::google::protobuf::uint32 value) {
  set_has_vm_id();
  vm_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.vm_id)
}

// required uint32 files_id = 2;
inline bool task_kobj_ids_entry::has_files_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_kobj_ids_entry::set_has_files_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_kobj_ids_entry::clear_has_files_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_kobj_ids_entry::clear_files_id() {
  files_id_ = 0u;
  clear_has_files_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::files_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.files_id)
  return files_id_;
}
inline void task_kobj_ids_entry::set_files_id(::google::protobuf::uint32 value) {
  set_has_files_id();
  files_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.files_id)
}

// required uint32 fs_id = 3;
inline bool task_kobj_ids_entry::has_fs_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void task_kobj_ids_entry::set_has_fs_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void task_kobj_ids_entry::clear_has_fs_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void task_kobj_ids_entry::clear_fs_id() {
  fs_id_ = 0u;
  clear_has_fs_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::fs_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.fs_id)
  return fs_id_;
}
inline void task_kobj_ids_entry::set_fs_id(::google::protobuf::uint32 value) {
  set_has_fs_id();
  fs_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.fs_id)
}

// required uint32 sighand_id = 4;
inline bool task_kobj_ids_entry::has_sighand_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void task_kobj_ids_entry::set_has_sighand_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void task_kobj_ids_entry::clear_has_sighand_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void task_kobj_ids_entry::clear_sighand_id() {
  sighand_id_ = 0u;
  clear_has_sighand_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::sighand_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.sighand_id)
  return sighand_id_;
}
inline void task_kobj_ids_entry::set_sighand_id(::google::protobuf::uint32 value) {
  set_has_sighand_id();
  sighand_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.sighand_id)
}

// optional uint32 pid_ns_id = 5;
inline bool task_kobj_ids_entry::has_pid_ns_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void task_kobj_ids_entry::set_has_pid_ns_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void task_kobj_ids_entry::clear_has_pid_ns_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void task_kobj_ids_entry::clear_pid_ns_id() {
  pid_ns_id_ = 0u;
  clear_has_pid_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::pid_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.pid_ns_id)
  return pid_ns_id_;
}
inline void task_kobj_ids_entry::set_pid_ns_id(::google::protobuf::uint32 value) {
  set_has_pid_ns_id();
  pid_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.pid_ns_id)
}

// optional uint32 net_ns_id = 6;
inline bool task_kobj_ids_entry::has_net_ns_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void task_kobj_ids_entry::set_has_net_ns_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void task_kobj_ids_entry::clear_has_net_ns_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void task_kobj_ids_entry::clear_net_ns_id() {
  net_ns_id_ = 0u;
  clear_has_net_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::net_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.net_ns_id)
  return net_ns_id_;
}
inline void task_kobj_ids_entry::set_net_ns_id(::google::protobuf::uint32 value) {
  set_has_net_ns_id();
  net_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.net_ns_id)
}

// optional uint32 ipc_ns_id = 7;
inline bool task_kobj_ids_entry::has_ipc_ns_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void task_kobj_ids_entry::set_has_ipc_ns_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void task_kobj_ids_entry::clear_has_ipc_ns_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void task_kobj_ids_entry::clear_ipc_ns_id() {
  ipc_ns_id_ = 0u;
  clear_has_ipc_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::ipc_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.ipc_ns_id)
  return ipc_ns_id_;
}
inline void task_kobj_ids_entry::set_ipc_ns_id(::google::protobuf::uint32 value) {
  set_has_ipc_ns_id();
  ipc_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.ipc_ns_id)
}

// optional uint32 uts_ns_id = 8;
inline bool task_kobj_ids_entry::has_uts_ns_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void task_kobj_ids_entry::set_has_uts_ns_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void task_kobj_ids_entry::clear_has_uts_ns_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void task_kobj_ids_entry::clear_uts_ns_id() {
  uts_ns_id_ = 0u;
  clear_has_uts_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::uts_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.uts_ns_id)
  return uts_ns_id_;
}
inline void task_kobj_ids_entry::set_uts_ns_id(::google::protobuf::uint32 value) {
  set_has_uts_ns_id();
  uts_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.uts_ns_id)
}

// optional uint32 mnt_ns_id = 9;
inline bool task_kobj_ids_entry::has_mnt_ns_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void task_kobj_ids_entry::set_has_mnt_ns_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void task_kobj_ids_entry::clear_has_mnt_ns_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void task_kobj_ids_entry::clear_mnt_ns_id() {
  mnt_ns_id_ = 0u;
  clear_has_mnt_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::mnt_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.mnt_ns_id)
  return mnt_ns_id_;
}
inline void task_kobj_ids_entry::set_mnt_ns_id(::google::protobuf::uint32 value) {
  set_has_mnt_ns_id();
  mnt_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.mnt_ns_id)
}

// optional uint32 user_ns_id = 10;
inline bool task_kobj_ids_entry::has_user_ns_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void task_kobj_ids_entry::set_has_user_ns_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void task_kobj_ids_entry::clear_has_user_ns_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void task_kobj_ids_entry::clear_user_ns_id() {
  user_ns_id_ = 0u;
  clear_has_user_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::user_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.user_ns_id)
  return user_ns_id_;
}
inline void task_kobj_ids_entry::set_user_ns_id(::google::protobuf::uint32 value) {
  set_has_user_ns_id();
  user_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.user_ns_id)
}

// optional uint32 cgroup_ns_id = 11;
inline bool task_kobj_ids_entry::has_cgroup_ns_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void task_kobj_ids_entry::set_has_cgroup_ns_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void task_kobj_ids_entry::clear_has_cgroup_ns_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void task_kobj_ids_entry::clear_cgroup_ns_id() {
  cgroup_ns_id_ = 0u;
  clear_has_cgroup_ns_id();
}
inline ::google::protobuf::uint32 task_kobj_ids_entry::cgroup_ns_id() const {
  // @@protoc_insertion_point(field_get:task_kobj_ids_entry.cgroup_ns_id)
  return cgroup_ns_id_;
}
inline void task_kobj_ids_entry::set_cgroup_ns_id(::google::protobuf::uint32 value) {
  set_has_cgroup_ns_id();
  cgroup_ns_id_ = value;
  // @@protoc_insertion_point(field_set:task_kobj_ids_entry.cgroup_ns_id)
}

// -------------------------------------------------------------------

// thread_sas_entry

// required uint64 ss_sp = 1;
inline bool thread_sas_entry::has_ss_sp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void thread_sas_entry::set_has_ss_sp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void thread_sas_entry::clear_has_ss_sp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void thread_sas_entry::clear_ss_sp() {
  ss_sp_ = GOOGLE_ULONGLONG(0);
  clear_has_ss_sp();
}
inline ::google::protobuf::uint64 thread_sas_entry::ss_sp() const {
  // @@protoc_insertion_point(field_get:thread_sas_entry.ss_sp)
  return ss_sp_;
}
inline void thread_sas_entry::set_ss_sp(::google::protobuf::uint64 value) {
  set_has_ss_sp();
  ss_sp_ = value;
  // @@protoc_insertion_point(field_set:thread_sas_entry.ss_sp)
}

// required uint64 ss_size = 2;
inline bool thread_sas_entry::has_ss_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void thread_sas_entry::set_has_ss_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void thread_sas_entry::clear_has_ss_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void thread_sas_entry::clear_ss_size() {
  ss_size_ = GOOGLE_ULONGLONG(0);
  clear_has_ss_size();
}
inline ::google::protobuf::uint64 thread_sas_entry::ss_size() const {
  // @@protoc_insertion_point(field_get:thread_sas_entry.ss_size)
  return ss_size_;
}
inline void thread_sas_entry::set_ss_size(::google::protobuf::uint64 value) {
  set_has_ss_size();
  ss_size_ = value;
  // @@protoc_insertion_point(field_set:thread_sas_entry.ss_size)
}

// required uint32 ss_flags = 3;
inline bool thread_sas_entry::has_ss_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void thread_sas_entry::set_has_ss_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void thread_sas_entry::clear_has_ss_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void thread_sas_entry::clear_ss_flags() {
  ss_flags_ = 0u;
  clear_has_ss_flags();
}
inline ::google::protobuf::uint32 thread_sas_entry::ss_flags() const {
  // @@protoc_insertion_point(field_get:thread_sas_entry.ss_flags)
  return ss_flags_;
}
inline void thread_sas_entry::set_ss_flags(::google::protobuf::uint32 value) {
  set_has_ss_flags();
  ss_flags_ = value;
  // @@protoc_insertion_point(field_set:thread_sas_entry.ss_flags)
}

// -------------------------------------------------------------------

// thread_core_entry

// required uint64 futex_rla = 1;
inline bool thread_core_entry::has_futex_rla() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void thread_core_entry::set_has_futex_rla() {
  _has_bits_[0] |= 0x00000001u;
}
inline void thread_core_entry::clear_has_futex_rla() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void thread_core_entry::clear_futex_rla() {
  futex_rla_ = GOOGLE_ULONGLONG(0);
  clear_has_futex_rla();
}
inline ::google::protobuf::uint64 thread_core_entry::futex_rla() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.futex_rla)
  return futex_rla_;
}
inline void thread_core_entry::set_futex_rla(::google::protobuf::uint64 value) {
  set_has_futex_rla();
  futex_rla_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.futex_rla)
}

// required uint32 futex_rla_len = 2;
inline bool thread_core_entry::has_futex_rla_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void thread_core_entry::set_has_futex_rla_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void thread_core_entry::clear_has_futex_rla_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void thread_core_entry::clear_futex_rla_len() {
  futex_rla_len_ = 0u;
  clear_has_futex_rla_len();
}
inline ::google::protobuf::uint32 thread_core_entry::futex_rla_len() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.futex_rla_len)
  return futex_rla_len_;
}
inline void thread_core_entry::set_futex_rla_len(::google::protobuf::uint32 value) {
  set_has_futex_rla_len();
  futex_rla_len_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.futex_rla_len)
}

// optional sint32 sched_nice = 3;
inline bool thread_core_entry::has_sched_nice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void thread_core_entry::set_has_sched_nice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void thread_core_entry::clear_has_sched_nice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void thread_core_entry::clear_sched_nice() {
  sched_nice_ = 0;
  clear_has_sched_nice();
}
inline ::google::protobuf::int32 thread_core_entry::sched_nice() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.sched_nice)
  return sched_nice_;
}
inline void thread_core_entry::set_sched_nice(::google::protobuf::int32 value) {
  set_has_sched_nice();
  sched_nice_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.sched_nice)
}

// optional uint32 sched_policy = 4;
inline bool thread_core_entry::has_sched_policy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void thread_core_entry::set_has_sched_policy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void thread_core_entry::clear_has_sched_policy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void thread_core_entry::clear_sched_policy() {
  sched_policy_ = 0u;
  clear_has_sched_policy();
}
inline ::google::protobuf::uint32 thread_core_entry::sched_policy() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.sched_policy)
  return sched_policy_;
}
inline void thread_core_entry::set_sched_policy(::google::protobuf::uint32 value) {
  set_has_sched_policy();
  sched_policy_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.sched_policy)
}

// optional uint32 sched_prio = 5;
inline bool thread_core_entry::has_sched_prio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void thread_core_entry::set_has_sched_prio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void thread_core_entry::clear_has_sched_prio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void thread_core_entry::clear_sched_prio() {
  sched_prio_ = 0u;
  clear_has_sched_prio();
}
inline ::google::protobuf::uint32 thread_core_entry::sched_prio() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.sched_prio)
  return sched_prio_;
}
inline void thread_core_entry::set_sched_prio(::google::protobuf::uint32 value) {
  set_has_sched_prio();
  sched_prio_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.sched_prio)
}

// optional uint64 blk_sigset = 6;
inline bool thread_core_entry::has_blk_sigset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void thread_core_entry::set_has_blk_sigset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void thread_core_entry::clear_has_blk_sigset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void thread_core_entry::clear_blk_sigset() {
  blk_sigset_ = GOOGLE_ULONGLONG(0);
  clear_has_blk_sigset();
}
inline ::google::protobuf::uint64 thread_core_entry::blk_sigset() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.blk_sigset)
  return blk_sigset_;
}
inline void thread_core_entry::set_blk_sigset(::google::protobuf::uint64 value) {
  set_has_blk_sigset();
  blk_sigset_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.blk_sigset)
}

// optional .thread_sas_entry sas = 7;
inline bool thread_core_entry::has_sas() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void thread_core_entry::set_has_sas() {
  _has_bits_[0] |= 0x00000040u;
}
inline void thread_core_entry::clear_has_sas() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void thread_core_entry::clear_sas() {
  if (sas_ != NULL) sas_->::thread_sas_entry::Clear();
  clear_has_sas();
}
inline const ::thread_sas_entry& thread_core_entry::sas() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.sas)
  return sas_ != NULL ? *sas_ : *default_instance_->sas_;
}
inline ::thread_sas_entry* thread_core_entry::mutable_sas() {
  set_has_sas();
  if (sas_ == NULL) sas_ = new ::thread_sas_entry;
  // @@protoc_insertion_point(field_mutable:thread_core_entry.sas)
  return sas_;
}
inline ::thread_sas_entry* thread_core_entry::release_sas() {
  clear_has_sas();
  ::thread_sas_entry* temp = sas_;
  sas_ = NULL;
  return temp;
}
inline void thread_core_entry::set_allocated_sas(::thread_sas_entry* sas) {
  delete sas_;
  sas_ = sas;
  if (sas) {
    set_has_sas();
  } else {
    clear_has_sas();
  }
  // @@protoc_insertion_point(field_set_allocated:thread_core_entry.sas)
}

// optional uint32 pdeath_sig = 8;
inline bool thread_core_entry::has_pdeath_sig() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void thread_core_entry::set_has_pdeath_sig() {
  _has_bits_[0] |= 0x00000080u;
}
inline void thread_core_entry::clear_has_pdeath_sig() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void thread_core_entry::clear_pdeath_sig() {
  pdeath_sig_ = 0u;
  clear_has_pdeath_sig();
}
inline ::google::protobuf::uint32 thread_core_entry::pdeath_sig() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.pdeath_sig)
  return pdeath_sig_;
}
inline void thread_core_entry::set_pdeath_sig(::google::protobuf::uint32 value) {
  set_has_pdeath_sig();
  pdeath_sig_ = value;
  // @@protoc_insertion_point(field_set:thread_core_entry.pdeath_sig)
}

// optional .signal_queue_entry signals_p = 9;
inline bool thread_core_entry::has_signals_p() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void thread_core_entry::set_has_signals_p() {
  _has_bits_[0] |= 0x00000100u;
}
inline void thread_core_entry::clear_has_signals_p() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void thread_core_entry::clear_signals_p() {
  if (signals_p_ != NULL) signals_p_->::signal_queue_entry::Clear();
  clear_has_signals_p();
}
inline const ::signal_queue_entry& thread_core_entry::signals_p() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.signals_p)
  return signals_p_ != NULL ? *signals_p_ : *default_instance_->signals_p_;
}
inline ::signal_queue_entry* thread_core_entry::mutable_signals_p() {
  set_has_signals_p();
  if (signals_p_ == NULL) signals_p_ = new ::signal_queue_entry;
  // @@protoc_insertion_point(field_mutable:thread_core_entry.signals_p)
  return signals_p_;
}
inline ::signal_queue_entry* thread_core_entry::release_signals_p() {
  clear_has_signals_p();
  ::signal_queue_entry* temp = signals_p_;
  signals_p_ = NULL;
  return temp;
}
inline void thread_core_entry::set_allocated_signals_p(::signal_queue_entry* signals_p) {
  delete signals_p_;
  signals_p_ = signals_p;
  if (signals_p) {
    set_has_signals_p();
  } else {
    clear_has_signals_p();
  }
  // @@protoc_insertion_point(field_set_allocated:thread_core_entry.signals_p)
}

// optional .creds_entry creds = 10;
inline bool thread_core_entry::has_creds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void thread_core_entry::set_has_creds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void thread_core_entry::clear_has_creds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void thread_core_entry::clear_creds() {
  if (creds_ != NULL) creds_->::creds_entry::Clear();
  clear_has_creds();
}
inline const ::creds_entry& thread_core_entry::creds() const {
  // @@protoc_insertion_point(field_get:thread_core_entry.creds)
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::creds_entry* thread_core_entry::mutable_creds() {
  set_has_creds();
  if (creds_ == NULL) creds_ = new ::creds_entry;
  // @@protoc_insertion_point(field_mutable:thread_core_entry.creds)
  return creds_;
}
inline ::creds_entry* thread_core_entry::release_creds() {
  clear_has_creds();
  ::creds_entry* temp = creds_;
  creds_ = NULL;
  return temp;
}
inline void thread_core_entry::set_allocated_creds(::creds_entry* creds) {
  delete creds_;
  creds_ = creds;
  if (creds) {
    set_has_creds();
  } else {
    clear_has_creds();
  }
  // @@protoc_insertion_point(field_set_allocated:thread_core_entry.creds)
}

// -------------------------------------------------------------------

// task_rlimits_entry

// repeated .rlimit_entry rlimits = 1;
inline int task_rlimits_entry::rlimits_size() const {
  return rlimits_.size();
}
inline void task_rlimits_entry::clear_rlimits() {
  rlimits_.Clear();
}
inline const ::rlimit_entry& task_rlimits_entry::rlimits(int index) const {
  // @@protoc_insertion_point(field_get:task_rlimits_entry.rlimits)
  return rlimits_.Get(index);
}
inline ::rlimit_entry* task_rlimits_entry::mutable_rlimits(int index) {
  // @@protoc_insertion_point(field_mutable:task_rlimits_entry.rlimits)
  return rlimits_.Mutable(index);
}
inline ::rlimit_entry* task_rlimits_entry::add_rlimits() {
  // @@protoc_insertion_point(field_add:task_rlimits_entry.rlimits)
  return rlimits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rlimit_entry >&
task_rlimits_entry::rlimits() const {
  // @@protoc_insertion_point(field_list:task_rlimits_entry.rlimits)
  return rlimits_;
}
inline ::google::protobuf::RepeatedPtrField< ::rlimit_entry >*
task_rlimits_entry::mutable_rlimits() {
  // @@protoc_insertion_point(field_mutable_list:task_rlimits_entry.rlimits)
  return &rlimits_;
}

// -------------------------------------------------------------------

// core_entry

// required .core_entry.march mtype = 1;
inline bool core_entry::has_mtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void core_entry::set_has_mtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void core_entry::clear_has_mtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void core_entry::clear_mtype() {
  mtype_ = 0;
  clear_has_mtype();
}
inline ::core_entry_march core_entry::mtype() const {
  // @@protoc_insertion_point(field_get:core_entry.mtype)
  return static_cast< ::core_entry_march >(mtype_);
}
inline void core_entry::set_mtype(::core_entry_march value) {
  assert(::core_entry_march_IsValid(value));
  set_has_mtype();
  mtype_ = value;
  // @@protoc_insertion_point(field_set:core_entry.mtype)
}

// optional .thread_info_x86 thread_info = 2;
inline bool core_entry::has_thread_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void core_entry::set_has_thread_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void core_entry::clear_has_thread_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void core_entry::clear_thread_info() {
  if (thread_info_ != NULL) thread_info_->::thread_info_x86::Clear();
  clear_has_thread_info();
}
inline const ::thread_info_x86& core_entry::thread_info() const {
  // @@protoc_insertion_point(field_get:core_entry.thread_info)
  return thread_info_ != NULL ? *thread_info_ : *default_instance_->thread_info_;
}
inline ::thread_info_x86* core_entry::mutable_thread_info() {
  set_has_thread_info();
  if (thread_info_ == NULL) thread_info_ = new ::thread_info_x86;
  // @@protoc_insertion_point(field_mutable:core_entry.thread_info)
  return thread_info_;
}
inline ::thread_info_x86* core_entry::release_thread_info() {
  clear_has_thread_info();
  ::thread_info_x86* temp = thread_info_;
  thread_info_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_thread_info(::thread_info_x86* thread_info) {
  delete thread_info_;
  thread_info_ = thread_info;
  if (thread_info) {
    set_has_thread_info();
  } else {
    clear_has_thread_info();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.thread_info)
}

// optional .thread_info_arm ti_arm = 6;
inline bool core_entry::has_ti_arm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void core_entry::set_has_ti_arm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void core_entry::clear_has_ti_arm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void core_entry::clear_ti_arm() {
  if (ti_arm_ != NULL) ti_arm_->::thread_info_arm::Clear();
  clear_has_ti_arm();
}
inline const ::thread_info_arm& core_entry::ti_arm() const {
  // @@protoc_insertion_point(field_get:core_entry.ti_arm)
  return ti_arm_ != NULL ? *ti_arm_ : *default_instance_->ti_arm_;
}
inline ::thread_info_arm* core_entry::mutable_ti_arm() {
  set_has_ti_arm();
  if (ti_arm_ == NULL) ti_arm_ = new ::thread_info_arm;
  // @@protoc_insertion_point(field_mutable:core_entry.ti_arm)
  return ti_arm_;
}
inline ::thread_info_arm* core_entry::release_ti_arm() {
  clear_has_ti_arm();
  ::thread_info_arm* temp = ti_arm_;
  ti_arm_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_ti_arm(::thread_info_arm* ti_arm) {
  delete ti_arm_;
  ti_arm_ = ti_arm;
  if (ti_arm) {
    set_has_ti_arm();
  } else {
    clear_has_ti_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.ti_arm)
}

// optional .thread_info_aarch64 ti_aarch64 = 8;
inline bool core_entry::has_ti_aarch64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void core_entry::set_has_ti_aarch64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void core_entry::clear_has_ti_aarch64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void core_entry::clear_ti_aarch64() {
  if (ti_aarch64_ != NULL) ti_aarch64_->::thread_info_aarch64::Clear();
  clear_has_ti_aarch64();
}
inline const ::thread_info_aarch64& core_entry::ti_aarch64() const {
  // @@protoc_insertion_point(field_get:core_entry.ti_aarch64)
  return ti_aarch64_ != NULL ? *ti_aarch64_ : *default_instance_->ti_aarch64_;
}
inline ::thread_info_aarch64* core_entry::mutable_ti_aarch64() {
  set_has_ti_aarch64();
  if (ti_aarch64_ == NULL) ti_aarch64_ = new ::thread_info_aarch64;
  // @@protoc_insertion_point(field_mutable:core_entry.ti_aarch64)
  return ti_aarch64_;
}
inline ::thread_info_aarch64* core_entry::release_ti_aarch64() {
  clear_has_ti_aarch64();
  ::thread_info_aarch64* temp = ti_aarch64_;
  ti_aarch64_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_ti_aarch64(::thread_info_aarch64* ti_aarch64) {
  delete ti_aarch64_;
  ti_aarch64_ = ti_aarch64;
  if (ti_aarch64) {
    set_has_ti_aarch64();
  } else {
    clear_has_ti_aarch64();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.ti_aarch64)
}

// optional .thread_info_ppc64 ti_ppc64 = 9;
inline bool core_entry::has_ti_ppc64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void core_entry::set_has_ti_ppc64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void core_entry::clear_has_ti_ppc64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void core_entry::clear_ti_ppc64() {
  if (ti_ppc64_ != NULL) ti_ppc64_->::thread_info_ppc64::Clear();
  clear_has_ti_ppc64();
}
inline const ::thread_info_ppc64& core_entry::ti_ppc64() const {
  // @@protoc_insertion_point(field_get:core_entry.ti_ppc64)
  return ti_ppc64_ != NULL ? *ti_ppc64_ : *default_instance_->ti_ppc64_;
}
inline ::thread_info_ppc64* core_entry::mutable_ti_ppc64() {
  set_has_ti_ppc64();
  if (ti_ppc64_ == NULL) ti_ppc64_ = new ::thread_info_ppc64;
  // @@protoc_insertion_point(field_mutable:core_entry.ti_ppc64)
  return ti_ppc64_;
}
inline ::thread_info_ppc64* core_entry::release_ti_ppc64() {
  clear_has_ti_ppc64();
  ::thread_info_ppc64* temp = ti_ppc64_;
  ti_ppc64_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_ti_ppc64(::thread_info_ppc64* ti_ppc64) {
  delete ti_ppc64_;
  ti_ppc64_ = ti_ppc64;
  if (ti_ppc64) {
    set_has_ti_ppc64();
  } else {
    clear_has_ti_ppc64();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.ti_ppc64)
}

// optional .task_core_entry tc = 3;
inline bool core_entry::has_tc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void core_entry::set_has_tc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void core_entry::clear_has_tc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void core_entry::clear_tc() {
  if (tc_ != NULL) tc_->::task_core_entry::Clear();
  clear_has_tc();
}
inline const ::task_core_entry& core_entry::tc() const {
  // @@protoc_insertion_point(field_get:core_entry.tc)
  return tc_ != NULL ? *tc_ : *default_instance_->tc_;
}
inline ::task_core_entry* core_entry::mutable_tc() {
  set_has_tc();
  if (tc_ == NULL) tc_ = new ::task_core_entry;
  // @@protoc_insertion_point(field_mutable:core_entry.tc)
  return tc_;
}
inline ::task_core_entry* core_entry::release_tc() {
  clear_has_tc();
  ::task_core_entry* temp = tc_;
  tc_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_tc(::task_core_entry* tc) {
  delete tc_;
  tc_ = tc;
  if (tc) {
    set_has_tc();
  } else {
    clear_has_tc();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.tc)
}

// optional .task_kobj_ids_entry ids = 4;
inline bool core_entry::has_ids() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void core_entry::set_has_ids() {
  _has_bits_[0] |= 0x00000040u;
}
inline void core_entry::clear_has_ids() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void core_entry::clear_ids() {
  if (ids_ != NULL) ids_->::task_kobj_ids_entry::Clear();
  clear_has_ids();
}
inline const ::task_kobj_ids_entry& core_entry::ids() const {
  // @@protoc_insertion_point(field_get:core_entry.ids)
  return ids_ != NULL ? *ids_ : *default_instance_->ids_;
}
inline ::task_kobj_ids_entry* core_entry::mutable_ids() {
  set_has_ids();
  if (ids_ == NULL) ids_ = new ::task_kobj_ids_entry;
  // @@protoc_insertion_point(field_mutable:core_entry.ids)
  return ids_;
}
inline ::task_kobj_ids_entry* core_entry::release_ids() {
  clear_has_ids();
  ::task_kobj_ids_entry* temp = ids_;
  ids_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_ids(::task_kobj_ids_entry* ids) {
  delete ids_;
  ids_ = ids;
  if (ids) {
    set_has_ids();
  } else {
    clear_has_ids();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.ids)
}

// optional .thread_core_entry thread_core = 5;
inline bool core_entry::has_thread_core() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void core_entry::set_has_thread_core() {
  _has_bits_[0] |= 0x00000080u;
}
inline void core_entry::clear_has_thread_core() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void core_entry::clear_thread_core() {
  if (thread_core_ != NULL) thread_core_->::thread_core_entry::Clear();
  clear_has_thread_core();
}
inline const ::thread_core_entry& core_entry::thread_core() const {
  // @@protoc_insertion_point(field_get:core_entry.thread_core)
  return thread_core_ != NULL ? *thread_core_ : *default_instance_->thread_core_;
}
inline ::thread_core_entry* core_entry::mutable_thread_core() {
  set_has_thread_core();
  if (thread_core_ == NULL) thread_core_ = new ::thread_core_entry;
  // @@protoc_insertion_point(field_mutable:core_entry.thread_core)
  return thread_core_;
}
inline ::thread_core_entry* core_entry::release_thread_core() {
  clear_has_thread_core();
  ::thread_core_entry* temp = thread_core_;
  thread_core_ = NULL;
  return temp;
}
inline void core_entry::set_allocated_thread_core(::thread_core_entry* thread_core) {
  delete thread_core_;
  thread_core_ = thread_core;
  if (thread_core) {
    set_has_thread_core();
  } else {
    clear_has_thread_core();
  }
  // @@protoc_insertion_point(field_set_allocated:core_entry.thread_core)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::core_entry_march> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::core_entry_march>() {
  return ::core_entry_march_descriptor();
}
template <> struct is_proto_enum< ::seccomp_mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::seccomp_mode>() {
  return ::seccomp_mode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_core_2eproto__INCLUDED
